/*
License:
  Currently there's no license restriction.You could use,modify it as you like.:)

*/
/*
@Author He.Ye (email:heyesh@cn.ibm.com)

Known Issue that is incompatible with Ecma-262(ECMAScript3 Specification)
1.[Lexer rule]RegularExpressionFirstChar must NOT be > , to avoid the consusable with XML Literal />

Known Issue that is incompatible with Ecma-357(ECMAScript for XML (E4X) Specification)
1. XMLName Lexer rule follows Ecma-262 Identifier rule (BUT can be a Reserved Word)

November 2008: Ernest Pasour - patched to add 'void' type as a valid function return type.
                             - interleaved helper code into grammar for purposes of supporting format/indent tool.
                             - changed memberExpression, callExpression and several others to use code from another grammar that handles function calls correctly.
                             - added ability to parse namespaces (double colon) in the code. ex. mOutputArea.mx_internal::getTextField();
                             - added support for binding declarations. ex. [Exclude(name="horizontalScrollBarStyleName", kind="style")]
                                                                           [IconFile("Accordion.png")] 
                                                                           [RequiresDataBinding(true)]
                             - added support for include directives
                             - added support for 'is' operator
                             - added support for '.*' in imports
                             - added support of 'as' operator
                             - added 'use namespace' directive
                             - added default xml namespace directive
                             - fixed implements to take a typeList instead of just a single type
                             - fixed formalParameterList to allow a single parameter that is an ellipsis
                             - added fileContents rule to allow a package declaration plus any combination of classes/interfaces/statements/directives afterward (i.e. outside the package)
                             	-I think this is the change that forced me to add -Xmx512m on the command line to prevent JDK OutOfMemoryError while processing the file.
                             - fixed identifierLiteral to allow keywords that aren't reserved
                             - fixed to allow xml attribute to allow any keyword to be used as an attribute name
                             - added support for xml attribute expressions ( ex. x.y.(@name=="abc").length()); )
                             - changed code that handles virtual semicolon to do lookahead for EOL/LineComment/MLComment instead of promoting token from non-hidden to hidden, which causes problems with the parser prediction phase
                             - fixed to allow trailing commas in array specifier, since that seems to be legal
January 2009				 - fixed to allow type specifier on ellipsis parameter.  Ex. override flash_proxy function callProperty(name:*, ... args:Array):*
February 2009				 - removed MUL_ASSIGN because of ambiguity with '*' type: ex. var x:*=2;
March 2009                   - added support for double negation ex. !!true or ~~true
                             - added support for conditional compiler code (ex. Config::debug {})
April 2009                   - added missing operators &&= and ||=
                             - added support for nested Vector declarations.  (ex. var nssets:Vector.<Vector.<String>> = new Vector.<Vector.<String>>(n+1);)
May 2009					 - fixed e4x to handle tagnames/attributes with hyphens/dots/colons (ex. <array-table></array-table>
							 - fixed e4x to allow var layers:XMLList = xmlData..ns::g.(@inkscape::groupmode =="layer");                             
June 2009                    - added ability to not indent at package level.  This is the way Adobe's example code is done, although the auto indent on carriage return in their editor doesn't agree
                             - added support for methods named "get" and "set".  I didn't think it was legal, but it appears to be.  This makes the grammar a little ambiguous, but it seems to work.
August 2009                  - added support for e4x attr names that are variable expressions.  Ex. <foo {attr}="value"/>
                             - added support for conditional blocks at the member level.  Ex. around a function or variable.  Grammar changes for packageElement and mxmlEmbedded, to support both AS classes and AS code fragments embedded within mxml.
October 2009                 - added support for using namespace to access members  Ex. mx_internal::functionCall(true);    

Currently building with Antlr 3.1.1                              
                             
*/
grammar AS3_ex;
options
{
//    backtrack=true;
    memoize=true;
    output=AST;
    //TokenLabelType=ASCommonToken;
    //ASTLabelType=ASCommonTree;
}

tokens{
    AS          =   'as';
    BREAK       =   'break';
    CASE        =   'case';
    CATCH       =   'catch';
    CLASS       =   'class';
    CONST       =   'const';
    CONTINUE    =   'continue';
    DEFAULT     =   'default';
    DELETE      =   'delete';
    DO          =   'do';
    ELSE        =   'else';
    EXTENDS     =   'extends';
    FALSE       =   'false';
    FINALLY     =   'finally';
    FOR         =   'for';
    FUNCTION    =   'function';
    IF          =   'if';
    IMPLEMENTS  =   'implements';
    IMPORT      =   'import';
    IN          =   'in';
    INSTANCEOF  =   'instanceof';
    INTERFACE   =   'interface';
    INTERNAL    =   'internal';
    IS          =   'is';
    NATIVE      =   'native';
    NEW         =   'new';
    NULL        =   'null';
    PACKAGE     =   'package';  
    PRIVATE     =   'private';
    PROTECTED   =   'protected';
    PUBLIC      =   'public';
    RETURN      =   'return';
    SUPER       =   'super';
    SWITCH      =   'switch';
    THIS        =   'this';
    THROW       =   'throw';
    TO          =   'to';
    TRUE        =   'true';
    TRY         =   'try';
    TYPEOF      =   'typeof';
    USE         =   'use';
    VAR         =   'var';
    VOID        =   'void';
    WHILE       =   'while';
    WITH        =   'with';
    
    // KEYWORDs but can be identifier
    EACH        =   'each';
    GET         =   'get';
    SET         =   'set';
    NAMESPACE   =   'namespace';
    INCLUDE     =   'include';
    DYNAMIC     =   'dynamic';
    FINAL       =   'final';
    OVERRIDE    =   'override';
    STATIC      =   'static';
    
    // Future KEYWORDS
    //ABSTRACT    =   'abstract';
    //BOOLEAN     =   'boolean';
    //BYTE        =   'byte';
    //CAST        =   'cast';
    //CHAR        =   'char';
    //DEBUGGER    =   'debugger';
    //DOUBLE      =   'double';
    //ENUM        =   'enum';
    //EXPORT      =   'export';
    //FLOAT       =   'float';
    //GOTO        =   'goto';
    //INTRINSIC   =   'intrinsic';
    //LONG        =   'long';
    //PROTOTYPE   =   'prototype';
    //SHORT       =   'short';
    //SYNCHRONIZED=   'synchronized';
    //THROWS      =   'throws';
    //TO          =   'to';
    //TRANSIENT   =   'transient';
    //TYPE        =   'type';
    //VIRTUAL     =   'virtual';
    //VOLATILE    =   'volatile';
    
    SEMI        = ';' ;
    LCURLY      = '{' ;
    RCURLY      = '}' ;
    LPAREN      = '(' ;
    RPAREN      = ')' ;
    LBRACK      = '[' ;
    RBRACK      = ']' ;
    DOT         = '.' ;
    COMMA       = ',' ;
    LT          = '<' ;
    GT          = '>' ;
    LTE         = '<=' ;
    GTE; //         = '>=' ;
    EQ          = '==' ;
    NEQ         = '!=' ;
    SAME        = '===' ;
    NSAME       = '!==' ;
    PLUS        = '+' ;
    SUB         = '-' ;
    STAR        = '*' ;
    DIV         = '/' ; 
    MOD         = '%' ;
    INC         = '++' ;
    DEC         = '--' ;
    SHL         = '<<' ;
    SHR;//         = '>>' ;
    SHU;//         = '>>>' ;
    AND         = '&' ;
    OR          = '|' ;
    XOR         = '^' ;
    NOT         = '!' ;
    INV         = '~' ;
    LAND        = '&&' ;
    LOR         = '||' ;
    QUE         = '?' ;
    COLON       = ':' ;
    ASSIGN      = '=' ;
    UNDERSCORE  = '_';
    DOLLAR      = '$';
//    MUL_ASSIGN  = '*=' ;
    DIV_ASSIGN  = '/=' ;
    MOD_ASSIGN  = '%=' ;
    ADD_ASSIGN  = '+=' ;
    SUB_ASSIGN  = '-=' ;
    SHL_ASSIGN  = '<<=';
    SHR_ASSIGN;//  = '>>=';
    SHU_ASSIGN;//  = '>>>=';
    LAND_ASSIGN = '&&=';
    LOR_ASSIGN  = '||=';
    AND_ASSIGN  = '&=' ;
    XOR_ASSIGN  = '^=' ;
    OR_ASSIGN   = '|=' ;
    ELLIPSIS    = '...';
    XML_ELLIPSIS='..';
    XML_TEND    = '/>';
    XML_E_TEND  = '</';
    XML_NS_OP   = '::';
    XML_AT      = '@';
    XML_LS_STD  = '<>';
    XML_LS_END  = '</>';
}
@header{
package flexprettyprint.handlers;
}
@lexer::header{
package flexprettyprint.handlers;
import heyesh.app.language.as3.parser.UnicodeUtil;
}
@lexer::members
{
    /**  */
    private Token lastDefaultCnlToken = null;
    
    // override
    public Token nextToken()
    {
        Token result = super.nextToken();
        if (result!=null && result.getType() != WHITESPACE )
        {
            lastDefaultCnlToken = result;
        }
        return result;      
    }    
    
public void reset()
{
	super.reset(); // reset all recognizer state variables
	if (input instanceof ANTLRStringStream)
	{
		((ANTLRStringStream)input).reset();
	}
}
    

	//TODO: fix this so that regular expression embedded within xml text will work
    private final boolean isRegularExpression(){
        if(lastDefaultCnlToken!=null){
            switch(lastDefaultCnlToken.getType()){
                case NULL :
                case TRUE :
                case FALSE:
                case THIS :
                case SUPER:
                case IDENTIFIER:
                case HEX_NUMBER_LITERAL:
                case DEC_NUMBER_LITERAL:
                case SINGLE_QUOTE_LITERAL:
                case DOUBLE_QUOTE_LITERAL:
                case RCURLY:
                case RBRACK:
                case RPAREN:
                    return false;
                default:
                    break;
            }
        }

        System.out.println("start to predict if is a ReglurExpression");
        // start to predict if the next is a regular expression
        int next = -1;
        int index=1;
        boolean success = false;
        if((next=input.LA(index)) != '/'){
            success = false;
            return success;
        }
        index++;
        // check the first regular character
        next=input.LA(index);
        if(next == '\r' || next == '\n' || next == '*' || next == '/' || next == '>'){
            success = false;
            return success;
        }else if(next == '\\'){
            next=input.LA(index+1);
            if(next == '\r' || next == '\n'){
                success=false;
                return success;
            }
            // we omit the escape sequence \ u XXXX or \ x XX
            index++;
        }
        index++;
        // check the body of regular character
        while((next=input.LA(index))!=-1){
            //System.out.println("char["+index+"] = ("+(char)next+")");
            switch(next){
                case '\r':
                case '\n':
                    success = false;
                    return success;
                case '\\':
                    next=input.LA(index+1);
                    if(next == '\r' || next == '\n'){
                        success=false;
                        return success;
                    }
                    // we omit the escape sequence \ u XXXX or \ x XX
                    index++;
                    break;
                case '/':
                    success = true;
                    return success;
            }            
            index++;
        }
        return success;
    }
        
   /**
    * <pre> judge if is a XMLName </pre>
    * @param ch character
    * @return if is a XMLName return true
    */
    static final boolean isXMLText(int ch){
        System.out.println("isXMLText start");
        return (ch!='{'&&ch!='<'&&!(isUnicodeIdentifierPart(ch)));
    }
        
    /*---------------------------UNICODE_INDENTIFER START------------------------------------------*/    
    private static final boolean isUnicodeIdentifierPart(int ch){
        return ch=='$'||ch=='_'||UnicodeUtil.isUnicodeLetter(ch)||UnicodeUtil.isUnicodeDigit(ch)||UnicodeUtil.isUnicodeCombiningMark(ch)||UnicodeUtil.isUnicodeConnectorPunctuation(ch);
    }
    
    private final void consumeIdentifierUnicodeStart() throws RecognitionException, NoViableAltException{
        int ch = input.LA(1);
        if (UnicodeUtil.isUnicodeLetter(ch) || ch=='$' || ch=='_')
        {
            matchAny();
            do
            {
                ch = input.LA(1);
                if (isUnicodeIdentifierPart(ch))
                {
                    mIDENT_PART();
                }
                else
                {
                    return;
                }
            }
            while (true);
        }
        else
        {
            throw new NoViableAltException();
        }
    }

    /*---------------------------UNICODE_INDENTIFER END------------------------------------------*/
    private final void debugMethod(String methodName,String text){
        System.out.println("recognized as <<"+methodName+">> text=("+text+")");
    }    
}
@parser::members{
   
   		//options
private List<Exception> mParseErrors;
		
private ASPrettyPrinter mPrinter;
private CommonTokenStream mRawTokens;

private List<Integer> mCodeBlockStack=new ArrayList<Integer>(); //this is used for tracking which block I'm in so that I can handle the open brace differently depending on context
private boolean mIsFunctionDecl; //flag that tells me whether the function body is associated with an expression or a declaration
private List<IfElseBlockTracker> mIfElseBlocks=new ArrayList<IfElseBlockTracker>();
private List<Boolean> mXMLTextContentStack=new ArrayList<Boolean>();

public AS3_exParser(ASPrettyPrinter printer, CommonTokenStream tokenStream)
{
	this(tokenStream, new RecognizerSharedState());
	mRawTokens=tokenStream;
    mPrinter=printer;
}

private static class IfElseBlockTracker
{
	public boolean mBlockFlag=false;
	public boolean mBlockFlagSet=false;
}

public void addIfElseBlockTracker()
{
	mIfElseBlocks.add(new IfElseBlockTracker());
}

public void popIfElseBlockTracker()
{
	if (mIfElseBlocks.size()>0)
		mIfElseBlocks.remove(mIfElseBlocks.size()-1);
}

public IfElseBlockTracker getCurrentIfElseTracker()
{
	if (mIfElseBlocks.size()>0)
		return mIfElseBlocks.get(mIfElseBlocks.size()-1);
		
	return null;
}

public void setBlockFlag(boolean flag)
{
	IfElseBlockTracker tracker=getCurrentIfElseTracker();
	if (tracker!=null)
	{
		//don't set if already set
		if (tracker.mBlockFlagSet)
			return;
			
		tracker.mBlockFlag=flag;
		tracker.mBlockFlagSet=true;
	}
}

public void markBlockFlag()
{
	IfElseBlockTracker tracker=getCurrentIfElseTracker();
	if (tracker!=null)
		tracker.mBlockFlagSet=true;
}

public void clearBlockFlag()
{
	IfElseBlockTracker tracker=getCurrentIfElseTracker();
	if (tracker!=null)
		tracker.mBlockFlagSet=false;
}

public boolean isBlockFlag()
{
	IfElseBlockTracker tracker=getCurrentIfElseTracker();
	if (tracker!=null)
		return tracker.mBlockFlag;
		
	return false;
}

private void popBlockStack()
{
	if (mCodeBlockStack.size()>0)
	{
		mCodeBlockStack.remove(mCodeBlockStack.size()-1);
	}
}

private void setXMLTextContentFlag()
{
	if (mXMLTextContentStack.size()>0)
	{
		mXMLTextContentStack.set(mXMLTextContentStack.size()-1, true);
	}
}

private void pushXMLTextContentFlag()
{
	mXMLTextContentStack.add(false);
}

private boolean popXMLTextContentFlag()
{
	if (mXMLTextContentStack.size()>0)
	{
		int index=mXMLTextContentStack.size()-1;
		boolean value=mXMLTextContentStack.get(index);
		mXMLTextContentStack.remove(index);
		return value;
	}
	return false;
}

private void emitXMLBreak(Token tok, boolean before)
{
	WrapOptions options=mPrinter.getXMLWrapOptions();
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS))
	{
		mPrinter.saveWrapChar(tok, ASPrettyPrinter.Break_XML_code, before, -1);
	}
}

public boolean foundNextLT()
{
   int i=1;
   while (true)
   {
       Token token=input.LT(i);
       if (token.getText()!=null && token.getText().startsWith("<"))
          return (i>1);
       if (token.getType()==EOF)
          return false;
       i++;   
   }
}

public void changeTokensUpToNextLT()
{
   int i=1;
   while (true)
   {
       Token t=input.LT(i);
       if (t.getText()!=null && t.getText().startsWith("<"))
          return;
       if (t.getType()==EOF)
          return;
       t.setType(XML_TEXT);          
          
       i++;   
   }
}

//this is for '.' and other similar characters that might cause a break
private void wrapEmit(Token item, int breakType)
{
	pushExpressionIndent(); //needs to be matched with a popIndent later
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && options.isBeforeSeparator())
	{
		insertMaxColumnCR();
	}
	emit(item);
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && !options.isBeforeSeparator())
	{
		insertMaxColumnCR();
	}
	
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS))
	{
		mPrinter.saveWrapChar(item, breakType, (breakType==ASPrettyPrinter.Break_Keyword_code) ? true : options.isBeforeSeparator(), -1);
	}
}

//this is for binary operators
private void indentEmit(Token operator, int breakType)
{
	pushExpressionIndent(); //needs to be matched with a popIndent later
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && options.isBeforeSeparator())
	{
		insertMaxColumnCR();
	}
	char firstChar=0;
	if (operator.getText().length()>0)
		firstChar=operator.getText().charAt(0);
	if (firstChar!=0)
	{
		if (Character.isJavaIdentifierPart(firstChar))
			insertWS(1); //add 1 space around text operators (ex. 'as', 'instanceof')
		else
			insertWS(mPrinter.getExpressionSpacesAroundSymbolicOperators()); //add configurable symbolic operator value
	}	
	emit(operator);
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && !options.isBeforeSeparator())
	{
		insertMaxColumnCR();
	}
	
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS))
	{
		mPrinter.saveWrapChar(operator, breakType, options.isBeforeSeparator(), -1);
	}
	
	if (firstChar!=0)
	{
		if (Character.isJavaIdentifierPart(firstChar))
			insertWS(1); //add 1 space around text operators (ex. 'as', 'instanceof')
		else
			insertWS(mPrinter.getExpressionSpacesAroundSymbolicOperators()); //add configurable symbolic operator value
	}	
}

private boolean pushWrapInfo(WrapOptions options, boolean newLevel)
{
	if (mPrinter.isDoFormat())
	{
		if (options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN)
		{
			mPrinter.createWrapContext(newLevel);
			return true;
		}
	}
	
	return false;
}

private boolean pushFormatType(WrapOptions options, boolean lazy)
{
	if (mPrinter.isDoFormat())
	{
		int formatMode=0;
		if (options.getWrapType()==WrapOptions.WRAP_DONT_PROCESS)
		{
			formatMode=ASPrettyPrinter.FORMAT_INDENT;
		}
		else if (options.getWrapType()==WrapOptions.WRAP_FORMAT_NO_CRs)
		{
			formatMode=ASPrettyPrinter.FORMAT_NOCRs;
		}
		else if (options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS)
		{
			formatMode=ASPrettyPrinter.FORMAT_OnlyAddCRs;
		}
		else
		{
			//if we didn't have a restrictive format, we want to make sure we're using the full format
			formatMode=ASPrettyPrinter.FORMAT_ALL;
		}

		if (formatMode>0)
		{
//		    if (formatMode==mPrinter.getFormatMode())
//		    	return false; //no need to nest format modes of the same type
		    	
			if (lazy)
				mPrinter.pushLazyFormat(formatMode);
			else
				mPrinter.pushFormatMode(formatMode);
			return true;
		}
		
	} 
	
	return false;
}

private void emitCRForTag(WrapOptions options)
{
	if (options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS)
	{
		insertMaxColumnCR();
	}
	else if (options.getWrapType()==WrapOptions.WRAP_BY_TAG)
	{
		insertCR(false);
	}

}

private boolean emitCommaWithSpacingAndCRs(WrapOptions options, Token comma, boolean pushedIndent, int firstParmLocation)
{
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && options.isBeforeSeparator())
	{
		insertMaxColumnCR();
	}
	
	if (!pushedIndent)
	{
		pushedIndent=true;
		pushExpressionIndent();
	}
	
    insertWS(mPrinter.getSpacesBeforeComma());
    emit(comma); 
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && !options.isBeforeSeparator())
	{
		insertMaxColumnCR();
	}
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS))
	{
		mPrinter.saveWrapChar(comma, ASPrettyPrinter.Break_Commas_code, options.isBeforeSeparator(), options.getIndentStyle()==WrapOptions.WRAP_STYLE_INDENT_TO_WRAP_ELEMENT ? firstParmLocation : -1);
	}
	insertWS(mPrinter.getSpacesAfterComma());
	return pushedIndent;
}

public boolean findVirtualHiddenToken(ParserRuleReturnScope retval)
{
        int index = retval.start.getTokenIndex();
        if(index<0){
            index = input.size();
        }
        for (int ix = index - 1; ix >= 0; ix--){
            Token lt = input.get(ix);
            int type = lt.getType();
            if(lt.getChannel() == Token.DEFAULT_CHANNEL)
                break;
            if (type == EOL || type==COMMENT_SINGLELINE || (type == COMMENT_MULTILINE && lt.getText().matches("/.*\r\n|\r|\n")))
            {
            	retval.start=lt;
                return true;
            }
        }
        return false;

}

public void reportError(RecognitionException e)
{
    if (mParseErrors==null)
    	mParseErrors=new ArrayList<Exception>();
    mParseErrors.add(e);
    super.reportError(e);
}
		
private void insertWS(int amt)
{
    mPrinter.insertWS(amt);
}

private void insertLines(int amt)
{
	insertLines(amt, true);
}

private void insertVariableDeclAssignmentWhitespace(Token equalToken, boolean before)
{
	if (mPrinter.isDoFormat() && !mPrinter.isInParameterDecl() && mPrinter.isKeepingExcessDeclWhitespace())
	{
		int spaceCount=0;
		if (before)
		{
			Token testToken=mRawTokens.get(equalToken.getTokenIndex()-1);
			if (testToken.getChannel()==CHANNEL_WHITESPACE)
			{
				//if the token before the whitespace is a carriage return, we *don't* want to apply this "preserve whitespace" logic
				Token prevTok=mRawTokens.get(equalToken.getTokenIndex()-2);
				if (!(prevTok.getChannel()==CHANNEL_SLCOMMENT || prevTok.getChannel()==CHANNEL_EOL))
				{
					if (testToken.getText().indexOf('\t')>=0)
					{
						spaceCount=mPrinter.getColumnForIndex(equalToken, 0)-mPrinter.getColumnForIndex(testToken, 0);
					}
					else
					{
					    spaceCount=testToken.getText().length();
					}
				}
			}
		}
		else
		{
			Token testToken=mRawTokens.get(equalToken.getTokenIndex()+1);
			if (testToken.getChannel()==CHANNEL_WHITESPACE)
			{
				//if the token after the whitespace is a carriage return, we *don't* want to apply this "preserve whitespace" logic
				//I think we only care about actual EOL here, not sl comment or ml comment, since there is actual text before the CR,
				//even if it's not 'code' text.
				Token nextTok=mRawTokens.get(equalToken.getTokenIndex()+2);
				if (!(nextTok.getChannel()==CHANNEL_EOL))
				{
					if (testToken.getText().indexOf('\t')>=0)
					{
						spaceCount=mPrinter.getColumnForIndex(testToken, testToken.getText().length())-mPrinter.getColumnForIndex(equalToken, equalToken.getText().length());
					}
					else
					{
					    spaceCount=testToken.getText().length();
					}
				}
			}
		}
		
		if (spaceCount>mPrinter.getSpacesAroundAssignment())
		{
			insertWS(spaceCount);
			return;
		}
	}
	
	insertWS(mPrinter.isInParameterDecl() ? mPrinter.getAdvancedSpacesAroundAssignmentInOptionalParameters() : mPrinter.getSpacesAroundAssignment());
}

//this method is for inserting blank lines before elements, based on the format settings
private void insertLines(int amt, boolean inCodeBlock)
{
    //don't add blank lines if not inside a block
	if (!mPrinter.isHardIndent())
	    return;
	//don't add blank lines if the wrapper is a labeled statement indent
	if (mPrinter.isLabeledIndent())
		return;
		
	//don't add blank lines if we are at start of block
	if (inCodeBlock)
	{
		if (!mPrinter.isCanAddCRsAtBlockStart() && mPrinter.isAtBlockStart())
		{
			return;
		}
	}
	
    for (int i=0;i<amt;i++)
    {
        mPrinter.insertCR(true);
    }
}

private void insertMaxColumnCR()
{
	mPrinter.insertCRBeyondMaxCol();
}

private void insertStatementCR()
{
	if (!mPrinter.isLabeledIndent())
		insertCR(false);
}
		
private void insertCR(boolean override)
{
    mPrinter.insertCR(override);
}
	
/*public int determineLastIndent(StringBuffer buffer)
{
	String[] lines=buffer.toString().split("\n");
	if (lines!=null && lines.length>0)
	{
		for (int i=lines.length-1;i>=0;i--)
		{
			String line=lines[i];
			for (int k=0;k<line.length();k++)
			{
				if (!Character.isWhitespace(line.charAt(k)))
				{
					//TODO: account for tabs
					return k;
				}
			}
		}
	}
	
	return 0;
}
*/
	
private void pushLabeledIndent()
{
	pushExpressionIndent(); //push an expression indent so that it won't further indent the nested statement 
	mPrinter.makeLabeledIndent();
}
	
private void pushIndent(boolean hardIndent)
{
	mPrinter.pushIndent(hardIndent ? ASPrettyPrinter.BRACE_INDENT : ASPrettyPrinter.STATEMENT_INDENT);
}

private void pushExpressionIndent()
{
	mPrinter.pushIndent(ASPrettyPrinter.EXPRESSION_INDENT);
}

private boolean pushLazyParmIndent(boolean alreadyPushed, int indentStyle)
{
	if (!alreadyPushed)
	{
		if (!mPrinter.isUseAdvancedWrapping() && indentStyle==WrapOptions.WRAP_STYLE_INDENT_TO_WRAP_ELEMENT)
			mPrinter.pushLazyIndent(ASPrettyPrinter.EXPRESSION_INDENT_NEXTITEM);
		else
			pushLazyIndent();
	}
	return true;
}

private void pushLazyIndent()
{
	mPrinter.pushLazyIndent(ASPrettyPrinter.EXPRESSION_INDENT);
}

private void popIndent()
{
    mPrinter.popIndent();
}
		
private void leftCurlyNewlineHandler(boolean checkBraceIndent)
{
   if (mPrinter.isCRBeforeOpenBrace(mCodeBlockStack) || (checkBraceIndent && mPrinter.getIndentType(0)==mPrinter.BRACE_INDENT))
       insertCR(false);
   else
       insertWS(1);
}
		
private void emit(Token tok)
{
    mPrinter.emit(tok);
}
		    
		
public List<Exception> getParseErrors()
{
    return mParseErrors;
}
		
/*        boolean isNotReservedWord(String name) {
        String[] reserveWords = new String[]
            {
                "as",
                "break",
                "case",
                "catch",
                "class",
                "const",
                "continue",
                "default",
                "delete",
                "do",
                "else",
                "extends",
                "false",
                "finally",
                "for",
                "function",
                "if",
                "implements",
                "import",
                "in",
                "instanceof",
                "interface",
                "internal",
                "is",
                "native",
                "new",
                "null",
                "package",
                "private",
                "protected",
                "public",
                "return",
                "super",
                "switch",
                "this",
                "throw",
                "to",
                "true",
                "try",
                "typeof",
                "use",
                "var",
                "void",
                "while",
                "with"
            };
        for (int i = 0; i<reserveWords.length; i++) {
            if ( reserveWords[i].equals(name) ) {
                return false;
            }
        }
        return true;
    }
    */
    
/*    private final void promoteEOL(ParserRuleReturnScope rule)
    {
        System.out.println("start promoteEOL <<let HIDDENT Token EOL be visible>>");
        Token lt = input.LT(1);
        int index = lt.getTokenIndex();
        if(index<0){
            index = input.size();
        }
        int la = lt.getType();
        
        for (int ix = index - 1; ix >= 0; ix--){
            lt = input.get(ix);
            int type = lt.getType();
            if (type == EOL || (type == COMMENT_MULTILINE && lt.getText().matches("/.*\r\n|\r|\n"))){
                lt.setChannel(Token.DEFAULT_CHANNEL);
                input.seek(lt.getTokenIndex());
                System.out.println("promoteEOL : HIDDEN Token ("+lt+") is set to DEFAULT");
                if (rule != null){
                    System.out.println("promoteEOL :  startToken set as "+lt);
                    rule.start = lt;
                }
                return;
            }else if(lt.getChannel() == Token.DEFAULT_CHANNEL){
                break;
            }
        }
        System.out.println("");
    }
  */
    
    public static final int CHANNEL_SLCOMMENT=43;
    public static final int CHANNEL_MLCOMMENT=42;
    public static final int CHANNEL_WHITESPACE=41;
    public static final int CHANNEL_EOL=40;
    
    private final boolean promoteWhitespace()
    {
    	//find the current lookahead token
        Token lt = input.LT(1);
        int index = lt.getTokenIndex();
        if(index<0){
            index = input.size();
        }

		//walk backward through tokens to see if the previous token is whitespace.
        for (int ix = index - 1; ix >= 0; ix--){
            lt = input.get(ix);
            int channel=lt.getChannel();
            if (channel == CHANNEL_EOL || channel ==  CHANNEL_WHITESPACE){
                return true;
            } else if(channel == Token.DEFAULT_CHANNEL){
                break;
            }
        }
        return false;
    }
}
// Lexer Helper Rule
fragment ALPHABET            :    'a'..'z'|'A'..'Z';

fragment NUMBER              :    '0' .. '9';   

fragment HEX_DIGIT           :    ('0' .. '9'|'a'..'f'|'A'..'F') ;

fragment CR                  :    '\r';

fragment LF                  :    '\n';

fragment UNICODE_ESCAPE      :    '\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;

fragment ESCAPE_SEQUENCE     :   '\\' ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\')
                                 |   UNICODE_ESCAPE
                                 ;
// Lexer Ignored Rule
EOL  
@after{
    debugMethod("EOL",$text);
}                        
    :    (CR LF | CR | LF)        
    { $channel = AS3_exParser.CHANNEL_EOL; };

WHITESPACE
@after{
    debugMethod("WHITESPACE",$text);
}
    :   (('\u0020'|'\u0009'|'\u000B'|'\u000C')|('\u001C'..'\u001F'))+              { $channel = AS3_exParser.CHANNEL_WHITESPACE; }
    ;
    
COMMENT_MULTILINE           
@after{
    debugMethod("COMMENT_MULTILINE",$text);
}
    :   '/*' ( options {greedy=false;} : . )* '*/'         { $channel = AS3_exParser.CHANNEL_MLCOMMENT; };

COMMENT_SINGLELINE
@after{
    debugMethod("COMMENT_SINGLELINE",$text);
}      
    :   '//' ~( CR | LF )* (CR LF | CR | LF)                          { $channel = AS3_exParser.CHANNEL_SLCOMMENT; };

// $<StringLiteral

SINGLE_QUOTE_LITERAL
@after{
    debugMethod("SINGLE_QUOTE_LITERAL",$text);
}          
    :   '\'' ( ESCAPE_SEQUENCE | ~('\\'|'\'') )* '\'';
DOUBLE_QUOTE_LITERAL         
@after{
    debugMethod("DOUBLE_QUOTE_LITERAL",$text);
} 
    :   '"'  ( ESCAPE_SEQUENCE | ~('\\'|'"') )* '"';

// $>

// $<RegularExpressionLiteral

REGULAR_EXPR_LITERAL
@after{
    debugMethod("REGULAR_EXPR_LITERAL",$text);
}
    :   {isRegularExpression()}? => DIV REGULAR_EXPR_BODY DIV REGULAR_EXPR_FLAG*
    ;

fragment REGULAR_EXPR_BODY
    :   REGULAR_EXPR_FIRST_CHAR REGULAR_EXPR_CHAR*
    ;   

// add > to the cannot be first char list
fragment REGULAR_EXPR_FIRST_CHAR
    :   ~(CR | LF |'*'|'\\'|'/'|'>')
    |   BACKSLASH_SEQUENCE
    ;

fragment REGULAR_EXPR_CHAR
    :   ~(CR | LF |'\\'|'/')
    |   BACKSLASH_SEQUENCE
    ;

fragment BACKSLASH_SEQUENCE:    '\\' ~(CR | LF);    
    
fragment REGULAR_EXPR_FLAG :    IDENT_PART ;

// $>

// $<NumberLiteral

HEX_NUMBER_LITERAL           
@after{
    debugMethod("HEX_NUMBER_LITERAL",$text);
} 
    : '0' ('X'|'x') HEX_DIGIT+ ;

fragment DEC_NUMBER          :  NUMBER+ '.' NUMBER* | '.' NUMBER+ | NUMBER+ ;

DEC_NUMBER_LITERAL
@after{
    debugMethod("DEC_NUMBER_LITERAL",$text);
} 
    :  DEC_NUMBER EXPONENT? ;

fragment EXPONENT            : ('e'|'E') ('+'|'-')? NUMBER+ ;

// $>

IDENTIFIER
@after{
    debugMethod("Identifier",$text);
} 
    :   IDENT_NAME_ASCII_START
    |   UNICODE_ESCAPE+
    |   {consumeIdentifierUnicodeStart();}
    ;
       
fragment IDENT_NAME_ASCII_START   : IDENT_ASCII_START IDENT_PART*;

fragment IDENT_ASCII_START        : ALPHABET | DOLLAR | UNDERSCORE;
    
fragment IDENT_PART 
@after{
    debugMethod("IDENT_PART",$text);
} 
    :   (IDENT_ASCII_START) => IDENT_ASCII_START
    |   NUMBER
    |   {isUnicodeIdentifierPart(input.LA(1))}? {matchAny();}
    ;
    
XML_COMMENT
@after{
    debugMethod("XML_COMMENT",$text);
}                  
    :   '<!--' ( options {greedy=false;} : . )* '-->';
    
XML_CDATA options {k=8;}
@after{
    debugMethod("XML_CDATA",$text);
}    
    :   '<![CDATA' ( options {greedy=false;} : . )* ']]>' ;
     
XML_PI
@after{
    debugMethod("XML_PI",$text);
}                      
    :   '<?' ( options {greedy=false;} : . )* '?>'; 

// SourceCharacters but no embedded left-curly { or less-than <    
XML_TEXT 
@after{
    debugMethod("XMLText",$text);
}   
    : '\u0020'..'\u003b'
    | '\u003d'..'\u007a'
    | '\u007c'..'\u007e'
    | {isXMLText(input.LA(1))}?{matchAny();}
    ;

    
// $<Literal

booleanLiteral                     :   T=TRUE {emit($T);} | F=FALSE{emit($F);} ;

numericLiteral                     :   D=DEC_NUMBER_LITERAL {emit($D);} | H=HEX_NUMBER_LITERAL {emit($H);};

stringLiteral                      :   S=SINGLE_QUOTE_LITERAL{emit($S);} | D=DOUBLE_QUOTE_LITERAL {emit($D);};

regularExpresionLiteral            :   R=REGULAR_EXPR_LITERAL {emit($R);};

identifierLiteral                  :   /*{isNotReservedWord(input.LT(1).getText())}?*/ I=IDENTIFIER{emit($I);} | notQuiteReservedWord ; 

xmlNameLiteral                     :   (I=IDENTIFIER{emit($I);} | allKeywords) ( {!promoteWhitespace()}?=> (s=SUB {emit($s);} | d=DOT {emit($d);} | c=COLON {emit($c);}) {!promoteWhitespace()}?=> (I2=IDENTIFIER {emit($I2);} | allKeywords))*
									; 

literal                            :   N=NULL {emit($N);} | booleanLiteral | numericLiteral | stringLiteral | regularExpresionLiteral;
// $>

xmlMarkup                          :   xmlComment | xmlCDATA | xmlPI;
xmlComment                         :   x=XML_COMMENT {emit($x);} ;  
xmlCDATA                           :   x=XML_CDATA {emit($x);}; 
xmlPI                              :   x=XML_PI {emit($x);} ; 
xmlExprEval                        :   L=LCURLY {emit($L);pushIndent(true);} expression R=RCURLY{popIndent();emit($R);} ; 


xmlTextElement
    :
		allKeywords {/*TODO: see if I can change token type*/} 
    | lexToken=(   DEC_NUMBER_LITERAL 
    | 	HEX_NUMBER_LITERAL
    |   SINGLE_QUOTE_LITERAL 
    | 	DOUBLE_QUOTE_LITERAL
    |   IDENTIFIER 
    |   XML_TEXT  //used to have a '+' on this item
    |   DIV 
    | 	SEMI 
//    | 	LCURLY //not allowed in xml text
    | 	RCURLY 
    | 	LPAREN 
    | 	RPAREN 
    |	LBRACK 
    |	RBRACK      
    |	DOT         
    |	COMMA       
//    |	LT          //not allowed in xml text
    |	GT          
    |	LTE         
//    |	GTE         
    |	EQ          
    |	NEQ         
    |	SAME        
    |	NSAME       
    |	PLUS        
    |	SUB         
    |	STAR        
    |	MOD         
    |	INC         
    |	DEC         
    |	SHL         
//    |	SHR         
//    |	SHU         
    |	AND         
    |	OR          
    |	XOR         
    |	NOT         
    |	INV         
    |	LAND        
    |	LOR         
    |	QUE         
    |	COLON       
    |	ASSIGN      
    |	UNDERSCORE  
    |	DOLLAR      
//    |	MUL_ASSIGN
    |	DIV_ASSIGN
    |	MOD_ASSIGN
    |	ADD_ASSIGN
    |	SUB_ASSIGN
    |	SHL_ASSIGN
//    |	SHR_ASSIGN
//    |	SHU_ASSIGN
    |	AND_ASSIGN
    |	XOR_ASSIGN
    |	OR_ASSIGN
    |   LOR_ASSIGN
    |   LAND_ASSIGN
    |	ELLIPSIS    
    |	XML_ELLIPSIS
    |	XML_NS_OP
    |	XML_AT
//    |	XML_LS_STD
 //   |	XML_LS_END
    ) 
    {
        lexToken.setType(XML_TEXT); 
        emit($lexToken);
    }
    ;

xmlText
    : 
    (xmlTextElement)+ 
    ;

// it's a helper rule,should not be a tree.
xmlPrimaryExpression 
    :   xmlPropertyIdentifier
    |   xmlInitialiser
    |   xmlListInitialiser
    ;                                                                      

/* 
    XMLPropertyIdentifier can be a primary expression, but also can be a propertySuffixReference
    see example
        :   var xml:XML = <soap:Envelope soap:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>;
            var soapNS:Namespace = message.namespace("soap");
            trace(xml.@soapNS::encodingStyle); //-> it's a propertySuffixReference Call
            with(xml){
                trace(@soapNS::encodingStyle); //-> it's a primaryExpression Call
            }
*/
xmlPropertyIdentifier
      :   xmlAttributeIdentifier
      |   xmlQualifiedIdentifier
//      |   s=STAR {emit($s);}                                    
      ;    

xmlAttributeIdentifier
    :   at=XML_AT {emit($at);} 
        (
           xmlQualifiedIdentifier
//           | xmlPropertySelector
           | indexSuffix
        )                                                        
    ; 
    
xmlPropertySelector
    :   xmlNameLiteral 
    |   s=STAR {emit($s);}
    ;

xmlQualifiedIdentifier
    :   xmlPropertySelector  x=XML_NS_OP {wrapEmit($x, ASPrettyPrinter.Break_Other_Connectors_code);}                 
    (
        xmlPropertySelector
        | indexSuffix
    )
    {popIndent();}
    ;

xmlInitialiser
    :   xmlMarkup
    |   xmlElement
    ;
    
xmlElement
@init
{
	WrapOptions options=mPrinter.getXMLWrapOptions();
	boolean pushedFormat=false;
	boolean pushedWrapInfo=false;
}
    :
    {pushedFormat=pushFormatType(options, true);}
    {pushedWrapInfo=pushWrapInfo(options, true);}
    {emitCRForTag(options);}
    L=LT {emit($L);}{emitXMLBreak($L, true);}{pushIndent(true);} xmlTagName xmlAttributes? 
    (
        x=XML_TEND {emit($x);}
        {emitCRForTag(options);}
        {popIndent();}
        | 
        G=GT {emit($G);pushXMLTextContentFlag();} xmlElementContent[false]? 
        x=XML_E_TEND {popIndent();}{emit($x);}{if (!popXMLTextContentFlag()) emitXMLBreak($x, true);} 
        xmlTagName G=GT{emit($G);}{emitCRForTag(options);} 
    )
    {
	    if (pushedWrapInfo) mPrinter.popWrapContext();
	    if (pushedFormat)
	    	mPrinter.popFormatMode();
    }
    ; 
    
xmlAttributes
    :   xmlAttribute+
    ;      
    
xmlTagName
    :   xmlExprEval
	| xmlNameLiteral
    ; 

xmlAttribute
    :  {promoteWhitespace()}? {insertWS(1);} xmlTagName A=ASSIGN {emit($A);} 
    (
        xmlExprEval
        | stringLiteral
    )
    ;
       
xmlElementContent[boolean crAfterTags]
    :  xmlElementContentHelper[crAfterTags]+
    ;

xmlElementContentHelper[boolean crAfterTags]
    : xmlExprEval {if (crAfterTags) insertCR(false);setXMLTextContentFlag();}
    | xmlMarkup {if (crAfterTags) insertCR(false);}
    | xmlElement {if (crAfterTags) insertCR(false);}
    | {mPrinter.pushFormatMode(ASPrettyPrinter.FORMAT_INDENT);}xmlText{mPrinter.popFormatMode();} {if (crAfterTags) insertCR(false);setXMLTextContentFlag();}
	;

xmlListInitialiser
@init
{
	WrapOptions options=mPrinter.getXMLWrapOptions();
	boolean pushedFormat=false;
}
    :
		{pushedFormat=pushFormatType(options, true);}    
        {insertCR(false);} x=XML_LS_STD 
  		{emit($x);}{insertCR(false);}{pushIndent(true);}
  		xmlElementContent[true]? 
  		{insertCR(false);} x=XML_LS_END {popIndent();}{emit($x);}{insertCR(false);}
	    {
		    if (pushedFormat)
		    	mPrinter.popFormatMode();
	    }
    ;

// semic rule
semic
@init
{
    // Mark current position so we can unconsume a RBRACE.
    int marker = input.mark();
    // Promote EOL if appropriate
    boolean onBrace=false;
    if (retval.start.getText()!=null && retval.start.getText().equals("}"))
    {
    	onBrace=true;
		if (state.backtracking>0)
		{
			retval.stop=retval.start;
		    return retval; //we don't want to consume the '}' during the prediction phase
		}    	
    }
    	
    if (findVirtualHiddenToken(retval))
    {
       retval.stop=retval.start;
       return retval;
    }
       
 //   promoteEOL(retval);
}
    :   S=SEMI{emit($S);} 
    |   E=EOF{emit($E);} 
    |   R=RCURLY { input.rewind(marker); 
                    if (onBrace)
                         retval.start=input.LT(-1);
                 }
//    |   C=COMMENT_MULTILINE {emit($C);} // (with EOL in it)
//    |   {isNextTokenHiddenVirtualSemi(retval)}?  E=EOL {emit($E);} 
    ;


fileContents
	: (packageDeclaration? packageElement*) | EOF
	;

// $<Package Declaration

packageDeclaration
	:   p=PACKAGE {{insertCR(false);}emit($p);pushExpressionIndent();} (type)? {popIndent();} 
	    l=LCURLY 
	    {
	  	   mCodeBlockStack.add(ASPrettyPrinter.BraceContext_package_code);
	       leftCurlyNewlineHandler(false);
	       emit($l);
	       if (mPrinter.isIndentAtPackageLevel())
	          pushIndent(true);
	       mCodeBlockStack.add(ASPrettyPrinter.BraceContext_block_code);
	    } 
	    packageElement* 
	    {
	    	if (mPrinter.isIndentAtPackageLevel())
	            popIndent();
	    } 
	    r=RCURLY {insertCR(false);emit($r);popBlockStack();popBlockStack();}
	;
			
/*//this is for actionscript embedded within mxml.  I believe that the semantics are that the code in
//the mx:Script blocks are embedded inside a virtual class declaration, so anything that is normally
//allowed inside a class should be okay.  However, imports are okay too.
mxmlEmbedded
	:
		({insertCR(false);} conditionalCompilerOption 
			l=LCURLY
			{ 
				mCodeBlockStack.add(ASPrettyPrinter.BraceContext_Conditional_code);
				leftCurlyNewlineHandler(false);
	    		emit($l);pushIndent(true);
	    		mCodeBlockStack.add(ASPrettyPrinter.BraceContext_block_code);
	    	}
			mxmlEmbedded
			{popIndent();} r=RCURLY {insertCR(false);emit($r);popBlockStack();popBlockStack();} 
	     | propertyDeclaration | functionDeclaration | statement | directive | interfaceFunctionDeclaration
	    )*  
	    EOF?
	;
*/	
				
packageElement
    :
    	{insertCR(false);} conditionalCompilerOption 
			l=LCURLY
			{ 
				mCodeBlockStack.add(ASPrettyPrinter.BraceContext_Conditional_code);
				leftCurlyNewlineHandler(false);
	    		emit($l);pushIndent(true);
	    		mCodeBlockStack.add(ASPrettyPrinter.BraceContext_block_code);
	    	}
			packageElement*
			{popIndent();} r=RCURLY {insertCR(false);emit($r);popBlockStack();popBlockStack();}	   
    	| classOrInterfaceDecl | propertyDeclaration | functionDeclaration | interfaceFunctionDeclaration | statement | directive
    ;

importDeclaration
	:   {insertCR(false);} i=IMPORT {emit($i);} type (D=DOT {emit($D);} S=STAR{emit($S);} )? semic 
	;

classOrInterfaceDecl
	:   {mPrinter.setBindingContext(ASPrettyPrinter.BindingContext_Class);} (conditionalDirAndBindingDecls)? {pushLazyIndent();}{insertCR(false);}{insertLines(mPrinter.getBlankLinesBeforeClass(), false);} memberModifiers? (interfaceDeclaration | classDeclaration)
	;
	
directive
	: {pushLazyIndent();}{insertCR(false);}(bindingDecl | includeDirective | useNamespaceDirective | importDeclaration | /*namespaceDirective |*/ defaultXMLNamespaceDirective){popIndent();}
	;
	
conditionalDirAndBindingDecls
	: {insertCR(false);} 	
	  {mPrinter.markBindablePos(true);}
	  conditionalCompilerOption 
      {mPrinter.setBindableMode();}
	  ({insertCR(false);} bindingDecl)*
	;
	
xmlKeyword
	: {input.LT(1).getText().equalsIgnoreCase("xml")}? I=IDENTIFIER {emit($I);} 
	;
	
conditionalCompilerOption
	:
	identifierLiteral x=XML_NS_OP {emit($x);} identifierLiteral
	;
	
defaultXMLNamespaceDirective
	: D=DEFAULT {emit($D);} xmlKeyword 
	//namespace
	N=NAMESPACE {emit($N);} 
	A=ASSIGN {emit($A);} I=IDENTIFIER {emit($I);} semic 
	;	
	
bindingDecl
@init
{boolean bindable=false;
 boolean pushedIndent=false;
	boolean pushedFormat=false;
	boolean pushedWrapInfo=false;
 WrapOptions options=mPrinter.getExpressionWrapOptions();
}
	:
    	{pushedFormat=pushFormatType(options, true);
    	 pushedWrapInfo=pushWrapInfo(options, true);
    	}
	   L=LBRACK  
		  I=IDENTIFIER 
		  	{
		  		bindable=mPrinter.isDirectiveForNextElement($I.getText());
		  		if (bindable)
		  			mPrinter.markBindablePos(false); //call this to mark position *before* we send any of the tokens to the printer
		  		emit($L); }
		  		{emit($I);
		  		mPrinter.setLastBindableTagName($I.getText());
		  	} 
		  (L=LPAREN {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParens());} 
		     (bindingDeclArg (C=COMMA {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, -1);} bindingDeclArg)*)? 
		   R=RPAREN{insertWS(mPrinter.getAdvancedSpacesInsideParens());emit($R);} 
	       )? 
	   R=RBRACK{emit($R);} (s=SEMI {emit($s);})?
	   {
        	if (pushedWrapInfo)
        		mPrinter.popWrapContext();
	        if (pushedIndent)
    	    	popIndent();
    	    if (pushedFormat)
    	    {
    	    	mPrinter.popFormatMode();
    	    }
	   	if (bindable)
	   	{
	   		mPrinter.setBindableMode();
	   	}
	   } 
	;
	
includeDirective
	: I=INCLUDE{emit($I);} stringLiteral semic  
	;
	
bindingDeclArg
	:
	//TODO: figure out what's actually legal here
//	(I=IDENTIFIER {emit($I);} E=ASSIGN {emit($E);})? expression  
//	| I=IDENTIFIER{emit($I);} 
//	| T=TRUE {emit($T);} 
//	| F=FALSE{emit($F);}
   
    (I=IDENTIFIER {emit($I);} E=ASSIGN {emit($E);} )? 
	(
		stringLiteral | numericLiteral | eitherIdentifier  
	);

// $>

// $<Class / Interface Body

interfaceDeclaration
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
	:   
	    i=INTERFACE {emit($i);} type 
		(e=EXTENDS 
			{pushedWrapInfo=pushWrapInfo(options, true);} {wrapEmit($e, ASPrettyPrinter.Break_Keyword_code);} 
			typeList
			{if (pushedWrapInfo) mPrinter.popWrapContext();}{popIndent();} 
		)? 
		{popIndent();}
        interfaceBody
	;	

interfaceBody
	:   l=LCURLY 
	    {
	    	mCodeBlockStack.add(ASPrettyPrinter.BraceContext_interface_code);
	    	leftCurlyNewlineHandler(false);
	    	emit($l);pushIndent(true);
	    	mCodeBlockStack.add(ASPrettyPrinter.BraceContext_block_code);
	    } 
	    interfaceElement* 
	    {popIndent();} 
	    r=RCURLY {insertCR(false);emit($r);popBlockStack();popBlockStack();}
	;	

classDeclaration
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
	:	
	    c=CLASS {emit($c);} type 
		( E=EXTENDS 
			{pushedWrapInfo=pushWrapInfo(options, true);}{wrapEmit($E, ASPrettyPrinter.Break_Keyword_code);}
			type
			{if (pushedWrapInfo) mPrinter.popWrapContext();}{popIndent();}
		)? 
		( I=IMPLEMENTS 
			{pushedWrapInfo=pushWrapInfo(options, true);} {wrapEmit($I, ASPrettyPrinter.Break_Keyword_code);} 
			typeList
			{if (pushedWrapInfo) mPrinter.popWrapContext();}{popIndent();}
		)? 
		{popIndent();}
        classBody 
    ;  
    
  

classBody
	:   L=LCURLY 
		{
			mCodeBlockStack.add(ASPrettyPrinter.BraceContext_class_code);
			leftCurlyNewlineHandler(false);
			emit($L);pushIndent(true);
			mCodeBlockStack.add(ASPrettyPrinter.BraceContext_block_code);
		} 
		classBodyElement* 
		{popIndent();} 
		R=RCURLY{insertCR(false);emit($R);popBlockStack();popBlockStack();} 
	;

// $>
	 
// $<Class/Interface Element

classBodyElement
    :   propertyDeclaration | functionDeclaration | statement | directive //| emptyStatement
	;

interfaceElement
    :   propertyDeclaration | interfaceFunctionDeclaration | statement| directive //| emptyStatement
    ;

// $>
	 


// $<InterfaceFunction Declaration

interfaceFunctionDeclaration
@init{
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	boolean pushedWrapInfo=false;
}
    :    {mPrinter.setBindingContext(ASPrettyPrinter.BindingContext_Function);} (conditionalDirAndBindingDecls)? {insertCR(false);} memberModifiers? F=FUNCTION {emit($F);}
       // getOrSet? 
    (S=SET{emit($S);} | G=GET{emit($G);} )?
    {pushedWrapInfo=pushWrapInfo(options, true);} 
    (I=IDENTIFIER {emit($I);} | notQuiteReservedWord) formalParameterList (C=COLON {insertWS(mPrinter.getAdvancedSpacesBeforeColons()); emit($C);insertWS(mPrinter.getAdvancedSpacesAfterColons());} type)? semic
    {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;

// $>

// $<Property Declaration

propertyDeclaration
	:    {insertLines(mPrinter.getBlankLinesBeforeProperties());mPrinter.setBindingContext(ASPrettyPrinter.BindingContext_Property);} (conditionalDirAndBindingDecls)? {insertCR(false);}{pushLazyIndent();} memberModifiers? (variableStatement | constantVarStatement | namespaceDirective) {popIndent();}
	;

// $>

// $<Function Definition (13)

functionDeclaration
@init{
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	boolean pushedWrapInfo=false;
}
    :    {mPrinter.setBindingContext(ASPrettyPrinter.BindingContext_Function);} (conditionalDirAndBindingDecls)? {pushLazyIndent();}{insertCR(false);insertLines(mPrinter.getBlankLinesBeforeFunction());} memberModifiers? F=FUNCTION {emit($F);} 
    (funcType=(SET|GET) {emit($funcType);})?
    {pushedWrapInfo=pushWrapInfo(options, true);} 
    (I=IDENTIFIER {emit($I);} | notQuiteReservedWord) formalParameterList (C=COLON {insertWS(mPrinter.getAdvancedSpacesBeforeColons());emit($C);insertWS(mPrinter.getAdvancedSpacesAfterColons());} type)? {popIndent();mIsFunctionDecl=true;} 
    {if (pushedWrapInfo) mPrinter.popWrapContext();}
    functionBody 
    ;

functionExpression
		//pop the indent to remove the lazy indent that is added by the surrounding expression.  Then add an indent
		//back at the end so that when the surrounding expression pops it will leave the correct number of indents.  Yuck.
    :   F=FUNCTION {emit($F);} (I=IDENTIFIER{emit($I);})? formalParameterList (C=COLON {insertWS(mPrinter.getAdvancedSpacesBeforeColons());emit($C);insertWS(mPrinter.getAdvancedSpacesAfterColons());} type)? {popIndent();mIsFunctionDecl=false;} functionBody
    	{pushExpressionIndent();}
    ;

formalParameterList
@init
{
	WrapOptions options=mPrinter.getMethodDeclWrapOptions();
	boolean pushedFormat=false;
	boolean pushedIndent=false;
	boolean pushedWrapInfo=false;
	int firstParm=0;
}
    :   
		{
			pushedFormat=pushFormatType(options, true);
			mPrinter.setInParameterDecl(true);
			pushedWrapInfo=pushWrapInfo(options, true);
		}
    	L=LPAREN {insertWS(mPrinter.getSpacesBeforeFormalParameters());}{emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParens());} 
        ( ( {pushedIndent=pushLazyParmIndent(pushedIndent, options.getIndentStyle());} {mPrinter.captureNextTextPosition();} variableDeclaration {firstParm=mPrinter.getLastCapturePosition();} 
            ( 
               C=COMMA 
               {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, firstParm);}
               variableDeclaration 
            )* 
            ( C=COMMA  {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, firstParm);} formalEllipsisParameter)?
           )
           | {pushedIndent=pushLazyParmIndent(pushedIndent, options.getIndentStyle());} formalEllipsisParameter
        )? 
        R=RPAREN {insertWS(mPrinter.getAdvancedSpacesInsideParens());emit($R);}
        
        {
        	 mPrinter.setInParameterDecl(false);
        	if (pushedWrapInfo)
        		mPrinter.popWrapContext();
	        if (pushedIndent)
    	    	popIndent();
    	    if (pushedFormat)
    	    {
    	    	mPrinter.popFormatMode();
    	    }
        } 
    ;
    
formalEllipsisParameter
    :   E=ELLIPSIS  {emit($E);insertWS(1);} variableIdentifierDecl
    ;   

functionBody
    :   L=LCURLY 
    	{
    		mCodeBlockStack.add(mIsFunctionDecl ? ASPrettyPrinter.BraceContext_functionDecl_code : ASPrettyPrinter.BraceContext_functionExpression_code);
    		leftCurlyNewlineHandler(false);
    		emit($L);pushIndent(true);
    		mCodeBlockStack.add(ASPrettyPrinter.BraceContext_block_code);
    	} 
    		(statement|functionDeclaration)* {popIndent();} 
    	R=RCURLY   {insertCR(false);emit($R);popBlockStack();popBlockStack();} 
    ;

// $>

// $<Member Modifiers

memberModifiers
    :   memberModifier+
    ;

//each
//	: {input.LT(1).getText().equals("each")}? I=IDENTIFIER{emit($I);} 
//	;
	
memberModifier
    :   x=(
        DYNAMIC
    |   FINAL
    |   INTERNAL
    |   NATIVE
    |   OVERRIDE
    |   PRIVATE
    |   PROTECTED
    |   PUBLIC
    |   STATIC
    |   IDENTIFIER //this is to handle the case of namespaces, which apparently don't have to be before other modifiers
    ) {emit($x);}
    ;

// $>


// statement

// $<Statement

statement
    :
    	{setBlockFlag(true);} blockStatement
    |   {insertStatementCR();}directive
    |   {insertStatementCR();}namespaceDirective
    |   {insertStatementCR();}{pushLazyIndent();} expression semic {popIndent();}
    |   {insertStatementCR();} {pushLazyIndent();}constantVarStatement {popIndent();}
    |   {markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());}tryStatement
    |   {insertLines(mPrinter.getBlankLinesBeforeControlStatement());}{insertStatementCR();}{mCodeBlockStack.add(ASPrettyPrinter.BraceContext_controlStatement_code);} labelledStatement {popBlockStack();} 
    |   {markBlockFlag();} switchStatement
    |   {markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());}{insertStatementCR();}{mCodeBlockStack.add(ASPrettyPrinter.BraceContext_controlStatement_code);} withStatement {popBlockStack();}
    |   {insertStatementCR();} {pushLazyIndent();} returnStatement {popIndent();}
    |   {insertStatementCR();} {pushLazyIndent();} breakStatement {popIndent();}
    |   {insertStatementCR();} {pushLazyIndent();} continueStatement {popIndent();}
    |   {markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());}{insertStatementCR();}{mCodeBlockStack.add(ASPrettyPrinter.BraceContext_controlStatement_code);} forStatement {popBlockStack();}
    |   {markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());}{insertStatementCR();}{mCodeBlockStack.add(ASPrettyPrinter.BraceContext_controlStatement_code);} forInStatement {popBlockStack();}
    |   {markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());}{insertStatementCR();}{mCodeBlockStack.add(ASPrettyPrinter.BraceContext_controlStatement_code);} forEachInStatement {popBlockStack();}
    |   {markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());}{insertStatementCR();}{mCodeBlockStack.add(ASPrettyPrinter.BraceContext_controlStatement_code);} doWhileStatement {popBlockStack();}
    |   {markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());}{insertStatementCR();}{mCodeBlockStack.add(ASPrettyPrinter.BraceContext_controlStatement_code);} whileStatement {popBlockStack();}
    |   {insertLines(mPrinter.getBlankLinesBeforeControlStatement());}ifStatement
    |   {if (mPrinter.isEmptyStatementsOnNewLine())insertStatementCR();}emptyStatement
    |   {insertStatementCR();} {pushLazyIndent();} variableStatement {popIndent();}
    |   {insertStatementCR();} {pushLazyIndent();} throwStatement {popIndent();}
    ;

// $>


// $<Block Statement

blockStatement
    :   ({insertCR(false);} conditionalToken=conditionalCompilerOption)? L=LCURLY 
    	{
    		if (conditionalToken!=null)
    			mCodeBlockStack.add(ASPrettyPrinter.BraceContext_Conditional_code);
    		leftCurlyNewlineHandler(conditionalToken==null); //if we have a conditional setting, then we want to have the option of keeping the brace on the same line
    		emit($L);}{pushIndent(true);
    		mCodeBlockStack.add(ASPrettyPrinter.BraceContext_block_code);
    	} 
    	statement* {popIndent();} 
    	R=RCURLY {insertCR(false);emit($R);popBlockStack();if (conditionalToken!=null) popBlockStack();}
    ;

// $>

throwStatement
	:  T=THROW {emit($T);} expression semic
	;

// $<Constant Var Statement

constantVarStatement
    :   C=CONST  {emit($C);} variableDeclarationList (S=SEMI{emit($S);})?                                                                              
    ; 
// $>


useNamespaceDirective
@init {
	boolean pushedIndent=false;
	boolean pushedFormat=false;
	boolean pushedWrapInfo=false;
 WrapOptions options=mPrinter.getExpressionWrapOptions();
}
	:
    	{pushedFormat=pushFormatType(options, true);
    	 pushedWrapInfo=pushWrapInfo(options, true);
    	}
	U=USE  {emit($U);} 
	N=NAMESPACE  {emit($N);} 
	qualifiedIdentifier (C=COMMA {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, -1);} qualifiedIdentifier)* semic
	{
    	if (pushedWrapInfo)
    		mPrinter.popWrapContext();
        if (pushedIndent)
	    	popIndent();
	    if (pushedFormat)
	    {
	    	mPrinter.popFormatMode();
	    }
	}
	;    
// $<UseNamespace Statement

// $<Namespace Directive

namespaceDirective
    :   //(memberModifiers)? //namespace
    N=NAMESPACE  {emit($N);}{pushExpressionIndent();} 
    qualifiedIdentifier ( A=ASSIGN  {insertWS(mPrinter.getSpacesAroundAssignment());emit($A);insertWS(mPrinter.getSpacesAroundAssignment());} stringLiteral )? semic {popIndent();}
    ;

// $>


// $<Try Statement(12.14)

tryStatement
    : {insertStatementCR();} T=TRY {emit($T);} {pushIndent(false);mCodeBlockStack.add(ASPrettyPrinter.BraceContext_try_code);} blockStatement {popIndent();popBlockStack();}
        ( catchClause* finallyClause?
//        | catchClause+
//        | finallyClause
        )
    ;

catchClause
    : {if (mPrinter.isCRBeforeCatch()) insertCR(false);}{insertWS(1);} C=CATCH {emit($C);insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());}{pushIndent(false);} L=LPAREN {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParens());} variableIdentifierDecl R=RPAREN {insertWS(mPrinter.getAdvancedSpacesInsideParens());emit($R);mCodeBlockStack.add(ASPrettyPrinter.BraceContext_catch_code);} blockStatement {popIndent();popBlockStack();}
    ;

finallyClause
    : {if (mPrinter.isCRBeforeCatch()) insertCR(false);}{insertWS(1);} F=FINALLY {emit($F);}{pushIndent(false);mCodeBlockStack.add(ASPrettyPrinter.BraceContext_finally_code);} blockStatement {popIndent();popBlockStack();}
    ;

// $>

// $<Labelled Statement(12.12)

labelledStatement
    :  I=IDENTIFIER {emit($I);}{pushLabeledIndent();} 
    	C=COLON 
    	{
    		emit($C);
    		insertWS(mPrinter.getSpacesAfterLabel());
    	} 
    	statement 
    	{popIndent();}
    ;

// $>

// $<switch Statement(12.11)

switchStatement
    :  {insertLines(mPrinter.getBlankLinesBeforeControlStatement());}{insertStatementCR();} S=SWITCH {emit($S);insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());}{pushExpressionIndent();} parExpression {popIndent();} 
    	L=LCURLY 
    	{
    		mCodeBlockStack.add(ASPrettyPrinter.BraceContext_controlStatement_code);
    		leftCurlyNewlineHandler(false);
    		emit($L);pushIndent(true);
    		mCodeBlockStack.add(ASPrettyPrinter.BraceContext_block_code);
    	} 
    	switchBlockStatementGroup* {popIndent();} 
    	R=RCURLY{insertCR(false);emit($R);popBlockStack();popBlockStack();} 
    ;
    
///* The change here (switchLabel -> switchLabel+) technically makes this grammar
//   ambiguous; but with appropriately greedy parsing it yields the most
 //  appropriate AST, one in which each group, except possibly the last one, has
 //  labels and statements. */
switchBlockStatementGroup
    :   {insertCR(false);} switchLabel {pushIndent(false);} statement* {popIndent();}{insertCR(false);} //breakStatement?
    ;
    
switchLabel
    :   C=CASE {emit($C);} {insertWS(1);} expression C=COLON 
    	{
    	emit($C);
    	insertWS(mPrinter.getSpacesAfterLabel());
    	} 
    |   D=DEFAULT {emit($D);} C=COLON
    		{
    			emit($C);
    			insertWS(mPrinter.getSpacesAfterLabel());
    		} 
    ;

// $>

// $<With statement(12.10)

withStatement
    :   W=WITH  {emit($W);insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());}{pushExpressionIndent();} L=LPAREN  {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParens());} expression  R=RPAREN  {insertWS(mPrinter.getAdvancedSpacesInsideParens());emit($R);}{popIndent();} {pushIndent(false);} statement {popIndent();}
    ;

// $>

// $<Return statment (12.9)

returnStatement
    :   R=RETURN {emit($R);} ( {insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());} expression)? semic 
    ;

// $>


// $<Break statement (12.8)

breakStatement
    :   B=BREAK    {emit($B);} (I=IDENTIFIER{emit($I);})? semic
    ;

// $>


// $<Continue statement (12.7)

continueStatement
    :   C=CONTINUE {emit($C);} (I=IDENTIFIER{emit($I);})? semic
    ;

// $>


// $<For statement 12.6

forStatement
    :   F=FOR {emit($F);insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());} {pushExpressionIndent();} L=LPAREN {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParens());} forControl R=RPAREN {insertWS(mPrinter.getAdvancedSpacesInsideParens());emit($R);}{popIndent();}{pushIndent(false);} statement {popIndent();}
    ;
    
forInStatement
    :   F=FOR {emit($F);insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());} {pushExpressionIndent();} L=LPAREN {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParens());} forInControl R=RPAREN {insertWS(mPrinter.getAdvancedSpacesInsideParens());emit($R);} {popIndent();} {pushIndent(false);} statement {popIndent();}
    ;  
    
forEachInStatement
    :   F=FOR {emit($F);} {pushExpressionIndent();}
     //   each 
    E=EACH {emit($E);insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());} 
    L=LPAREN {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParens());} forInControl R=RPAREN {insertWS(mPrinter.getAdvancedSpacesInsideParens());emit($R);}{popIndent();}{pushIndent(false);} statement {popIndent();}     
	;
forControl
options {k=3;} // be efficient for common case: for (ID ID : ID) ...
    :   forInit? {insertWS(mPrinter.getSpacesBeforeComma());} semic  {insertWS(mPrinter.getSpacesAfterComma());} expression? {insertWS(mPrinter.getSpacesBeforeComma());}semic {insertWS(mPrinter.getSpacesAfterComma());} forUpdate?
    ;

forInControl
options {k=3;} // be efficient for common case: for (ID ID : ID) ...
    :   forInDecl I=IN {emit($I);} expression
    ;

forInDecl
    :   leftHandSideExpression
    |   V=VAR {emit($V);} variableDeclarationNoIn
    ;

forInit
    :   variableDeclarationNoInList
    |   expressionNoIn
    ;

forUpdate
    :   expression
    ;

// $>


// $<While statement (12.5)

doWhileStatement
    :   D=DO {emit($D);} {pushIndent(false);} statement {popIndent();}{insertWS(1);} {pushExpressionIndent();} W=WHILE {emit($W);insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());} parExpression semic (S=SEMI{emit($S);})? {popIndent();}
    ;

// $>

// $<While statement (12.5)

whileStatement
    :   W=WHILE {emit($W);insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());}{pushExpressionIndent();} parExpression {popIndent();} {pushIndent(false);} statement {popIndent();}
    ;
    
// $>



// $<If statement (12.5)

ifStatement
@init 
{
   Token tok=null;
   boolean ifOnSameLine=false;
   boolean wasBlock=false;
}
    :      
        {
           tok=mPrinter.getLastToken(); 
           //if the previous token was not an else, then insert a CR.  Also if it is an 'else' but the setting says to put the 'if' on a new line
           if (!mPrinter.isKeepElseIfOnSameLine() || (tok==null) || !tok.getText().equals("else"))
           {
           		insertStatementCR();
           }

           if (tok!=null && tok.getText().equals("else"))
           {
           		mPrinter.setElseIfState();
           }
        } 
         I=IF 
         {
              emit($I);
              ifOnSameLine=mPrinter.getElseIfNeedToLoseIndent();
              if (ifOnSameLine)
                  popIndent();
              insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());
         }
         {pushExpressionIndent();} 
         parExpression 
         {popIndent();}
         {pushIndent(false);}
         {addIfElseBlockTracker();setBlockFlag(false);clearBlockFlag();}
         {mCodeBlockStack.add(ASPrettyPrinter.BraceContext_controlStatement_code);}
         statement
         {popBlockStack();} 
         {wasBlock=isBlockFlag();popIfElseBlockTracker();}
         {popIndent();}
          
         (options {k=1;}:E=ELSE 
	         {
	          Token tempTok=mPrinter.getLastToken();
	          if (mPrinter.isCRBeforeElse() || !wasBlock)//tempTok==null || !tempTok.getText().equals("}")) 
	              insertCR(false);
	         }
	         {insertWS(1);}
	         {emit($E);} {pushIndent(false);}{mCodeBlockStack.add(ASPrettyPrinter.BraceContext_controlStatement_code);} statement {popBlockStack();}{popIndent();})?
			{if (ifOnSameLine)
            	pushIndent(false);}
	          
    ;
    
// $>   
    

// $<Empty statement (12.3)

emptyStatement 
    :     S=SEMI {emit($S);} 
    ;

// $>


// $<Variable statement 12.2)

variableStatement
@init{
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	boolean pushedFormat=false;
	boolean pushedWrapInfo=false;
	boolean pushedIndent=false;
}
    :
    	{pushedFormat=pushFormatType(options, true);
    	 pushedWrapInfo=pushWrapInfo(options, true);
    	}
        (I=IDENTIFIER {emit($I);})? V=VAR {emit($V);} variableDeclaration ( C=COMMA {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, -1);} variableDeclaration )* semic
    	{
    		if (pushedIndent)
    			popIndent();
	   	    if (pushedFormat)
	   	    {
	   	    	mPrinter.popFormatMode();
	   	    }
	   	    if (pushedWrapInfo)
	   	    	mPrinter.popWrapContext();
    	}
         
    ;
    
variableDeclarationList
@init{
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	boolean pushedFormat=false;
	boolean pushedWrapInfo=false;
	boolean pushedIndent=false;
}
    :
    	{pushedFormat=pushFormatType(options, true);
    	 pushedWrapInfo=pushWrapInfo(options, true);
    	}
         variableDeclaration (  C=COMMA {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, -1);} variableDeclaration)*
    	{
    		if (pushedIndent)
    			popIndent();
	   	    if (pushedFormat)
	   	    {
	   	    	mPrinter.popFormatMode();
	   	    }
	   	    if (pushedWrapInfo)
	   	    	mPrinter.popWrapContext();
    	}
    ;
    
variableDeclarationNoInList
@init{
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	boolean pushedFormat=false;
	boolean pushedWrapInfo=false;
	boolean pushedIndent=false;
}
    :
    	{pushedFormat=pushFormatType(options, true);
    	 pushedWrapInfo=pushWrapInfo(options, true);
    	}
        (V=VAR{emit($V);} )? variableDeclarationNoIn ( C=COMMA {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, -1);} variableDeclarationNoIn)*
    	{
    		if (pushedIndent)
    			popIndent();
	   	    if (pushedFormat)
	   	    {
	   	    	mPrinter.popFormatMode();
	   	    }
	   	    if (pushedWrapInfo)
	   	    	mPrinter.popWrapContext();
    	}
    ;
    
variableDeclaration
@init {
	WrapOptions options=mPrinter.getExpressionWrapOptions();
}
    :   variableIdentifierDecl ( A=ASSIGN 
    	{
    		insertVariableDeclAssignmentWhitespace($A, true);
    		wrapEmit($A, ASPrettyPrinter.Break_Assignment_code);
    		insertVariableDeclAssignmentWhitespace($A, false);
    	} 
    	assignmentExpression {popIndent();})?
    ;

variableDeclarationNoIn
@init {
	WrapOptions options=mPrinter.getExpressionWrapOptions();
}
    :    variableIdentifierDecl ( A=ASSIGN 
         {
          insertVariableDeclAssignmentWhitespace($A, true);
          wrapEmit($A, ASPrettyPrinter.Break_Assignment_code);
          insertVariableDeclAssignmentWhitespace($A, false);
         } 
         assignmentExpressionNoIn {popIndent();})?
    ;
    
variableIdentifierDecl
    :    identifierLiteral ( C=COLON {insertWS(mPrinter.getAdvancedSpacesBeforeColons());emit($C);insertWS(mPrinter.getAdvancedSpacesAfterColons());} type )?
    ;
// $>
    
// $<Type / Type List

type:   qualifiedName | S=STAR {emit($S);} | V=VOID {emit($V);} ;

typeList
@init{
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	boolean pushedFormat=false;
	boolean pushedWrapInfo=false;
	boolean pushedIndent=false;
}
    :
    	{pushedFormat=pushFormatType(options, true);
    	 pushedWrapInfo=pushWrapInfo(options, true);
    	}
       type (C=COMMA {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, -1);} type)*
    	{
    		if (pushedIndent)
    			popIndent();
	   	    if (pushedFormat)
	   	    {
	   	    	mPrinter.popFormatMode();
	   	    }
	   	    if (pushedWrapInfo)
	   	    	mPrinter.popWrapContext();
    	}
    ; 
// $>
     
standardQualifiedName
	:
	typeSpecifier (D=DOT {wrapEmit($D, ASPrettyPrinter.Break_Other_Connectors_code);} typeSpecifier {popIndent();})*
//	(I=IDENTIFIER {emit($I);} ) (D=DOT {emit($D);} (I=IDENTIFIER{emit($I);} ) )*
	;
	
qualifiedName 
    :   
    	standardQualifiedName (typePostfixSyntax)? 
    ;
    
typePostfixSyntax:
	D=DOT {wrapEmit($D, ASPrettyPrinter.Break_Other_Connectors_code);} L=LT {emit($L);} standardQualifiedName (typePostfixSyntax)? G=GT {emit($G);}{popIndent();}
	;
    
qualifiedIdentifier
    :   /*{isNotReservedWord(input.LT(1).getText())}?*/
    	I=IDENTIFIER {emit($I);} 
    ;


// Expression

parExpression
@init
{
	boolean pushedWrap=false;
	WrapOptions options=mPrinter.getExpressionWrapOptions();
}
    :
    {pushedWrap=pushWrapInfo(options, true);}
    L=LPAREN  {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParens());} {pushExpressionIndent();} expression  R=RPAREN {insertWS(mPrinter.getAdvancedSpacesInsideParens());emit($R);} {popIndent();}
    {if (pushedWrap) mPrinter.popWrapContext();} 
    ;

expression
@init{
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	boolean pushedFormat=false;
	boolean pushedWrapInfo=false;
	boolean pushedIndent=false;
}
    :   
    	{pushedFormat=pushFormatType(options, true);
    	 pushedWrapInfo=pushWrapInfo(options, true);
    	}
    	assignmentExpression (  C=COMMA  {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, -1);} assignmentExpression)*
    	{
    		if (pushedIndent)
    			popIndent();
	   	    if (pushedFormat)
	   	    {
	   	    	mPrinter.popFormatMode();
	   	    }
	   	    if (pushedWrapInfo)
	   	    	mPrinter.popWrapContext();
    	}
    ;

expressionNoIn
@init{
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	boolean pushedFormat=false;
	boolean pushedWrapInfo=false;
	boolean pushedIndent=false;
}
    :
    	{pushedFormat=pushFormatType(options, true);
    	 pushedWrapInfo=pushWrapInfo(options, true);
    	}
       assignmentExpressionNoIn (  C=COMMA  {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, -1);} assignmentExpressionNoIn)*
    	{
    		if (pushedIndent)
    			popIndent();
	   	    if (pushedFormat)
	   	    {
	   	    	mPrinter.popFormatMode();
	   	    }
	   	    if (pushedWrapInfo)
	   	    	mPrinter.popWrapContext();
    	}
    ;

//11.13 Assignment Operators
assignmentExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :  
       {pushedWrapInfo=pushWrapInfo(options, true);} 
      (leftHandSideExpression  assignmentOperator  assignmentExpression
    	| conditionalExpression
       )
       {if (pushedWrapInfo)
	   	    mPrinter.popWrapContext();}
    ;


assignmentExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :  {pushedWrapInfo=pushWrapInfo(options, true);}
       (
    	  leftHandSideExpression  assignmentOperator  assignmentExpressionNoIn
    	| conditionalExpressionNoIn
    	)
       {if (pushedWrapInfo)
	   	    mPrinter.popWrapContext();}
    ;

assignmentOperator
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
}
	: op=assignmentOperator_int 
	  {insertWS(mPrinter.getSpacesAroundAssignment());
	   emit($op.start);
	   mPrinter.saveWrapChar($op.start, ASPrettyPrinter.Break_Assignment_code, options.isBeforeSeparator(), -1);
	   insertWS(mPrinter.getSpacesAroundAssignment());
	  }
	;
	     
assignmentOperator_int
    : ASSIGN 
//    | MUL_ASSIGN
	| s=STAR a=ASSIGN! {s.setText("*=");}
    | DIV_ASSIGN 
    | MOD_ASSIGN 
    | ADD_ASSIGN 
    | SUB_ASSIGN
    | SHL_ASSIGN
//    | SHR_ASSIGN
//    | SHU_ASSIGN 
/*    | (('<' '<' '=')=> t1='<' t2='<' t3='=' 
        { $t1.getLine() == $t2.getLine() &&
          $t1.getCharPositionInLine() + 1 == $t2.getCharPositionInLine() && 
          $t2.getLine() == $t3.getLine() && 
          $t2.getCharPositionInLine() + 1 == $t3.getCharPositionInLine() }?
      -> SHL_ASSIGN){ t1.setText("<<=");} */
    |   (('>' '>' '=')=> t1='>' t2='>' t3='='
        { $t1.getLine() == $t2.getLine() && 
          $t1.getCharPositionInLine() + 1 == $t2.getCharPositionInLine() && 
          $t2.getLine() == $t3.getLine() && 
          $t2.getCharPositionInLine() + 1 == $t3.getCharPositionInLine() }?
      -> SHR_ASSIGN) {t1.setText(">>=");}

    | (('>' '>' '>' '=')=> t1='>' t2='>' t3='>' t4='='
        { $t1.getLine() == $t2.getLine() && 
          $t1.getCharPositionInLine() + 1 == $t2.getCharPositionInLine() &&
          $t2.getLine() == $t3.getLine() && 
          $t2.getCharPositionInLine() + 1 == $t3.getCharPositionInLine() &&
          $t3.getLine() == $t4.getLine() && 
          $t3.getCharPositionInLine() + 1 == $t4.getCharPositionInLine() }?
      -> SHU_ASSIGN) {t1.setText(">>>=");}
    | AND_ASSIGN 
    | XOR_ASSIGN 
    | OR_ASSIGN
    | LOR_ASSIGN
    | LAND_ASSIGN
    ;

//11.12 Conditional Operator ( ?: )
conditionalExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        logicalORExpression ( Q=QUE  {indentEmit($Q, ASPrettyPrinter.Break_Ternary_code);} assignmentExpression  {popIndent();} C=COLON  {indentEmit($C, ASPrettyPrinter.Break_Ternary_code);} assignmentExpression {popIndent();})?
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;
    
conditionalExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        logicalORExpressionNoIn ( Q=QUE {indentEmit($Q, ASPrettyPrinter.Break_Ternary_code);} assignmentExpression  {popIndent();} C=COLON  {indentEmit($C, ASPrettyPrinter.Break_Ternary_code);} assignmentExpression {popIndent();})?
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;    
    
//11.11 Binary Logical Operators
logicalORExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        logicalANDExpression ( L=LOR {indentEmit($L, ASPrettyPrinter.Break_Logical_Ops_code);} logicalANDExpression {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ; 
    
logicalORExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        logicalANDExpressionNoIn ( L=LOR {indentEmit($L, ASPrettyPrinter.Break_Logical_Ops_code);} logicalANDExpressionNoIn {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;     
    
logicalANDExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        bitwiseORExpression ( L=LAND {indentEmit($L, ASPrettyPrinter.Break_Logical_Ops_code);} bitwiseORExpression {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;
    
logicalANDExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        bitwiseORExpressionNoIn ( L=LAND {indentEmit($L, ASPrettyPrinter.Break_Logical_Ops_code);} bitwiseORExpressionNoIn {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;    
    
//11.10 Binary Bitwise Operators
bitwiseORExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        bitwiseXORExpression ( O=OR {indentEmit($O, ASPrettyPrinter.Break_Arithmetic_Ops_code);} bitwiseXORExpression {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;
    
bitwiseORExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        bitwiseXORExpressionNoIn ( O=OR {indentEmit($O, ASPrettyPrinter.Break_Arithmetic_Ops_code);} bitwiseXORExpressionNoIn {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;    
    
bitwiseXORExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        bitwiseANDExpression ( x=XOR {indentEmit($x, ASPrettyPrinter.Break_Arithmetic_Ops_code);} bitwiseANDExpression {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;
    
bitwiseXORExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        bitwiseANDExpressionNoIn ( x=XOR {indentEmit($x, ASPrettyPrinter.Break_Arithmetic_Ops_code);} bitwiseANDExpressionNoIn {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;    

bitwiseANDExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        equalityExpression ( A=AND {indentEmit($A, ASPrettyPrinter.Break_Arithmetic_Ops_code);} equalityExpression {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;
    
bitwiseANDExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        equalityExpressionNoIn ( A=AND {indentEmit($A, ASPrettyPrinter.Break_Arithmetic_Ops_code);} equalityExpressionNoIn {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;    

//11.9 Equality Operators
equalityExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        relationalExpression ( eq=(EQ|NEQ|SAME|NSAME){indentEmit($eq, ASPrettyPrinter.Break_Arithmetic_Ops_code);}  relationalExpression {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;
    
equalityExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        relationalExpressionNoIn ( eq=(EQ|NEQ|SAME|NSAME) {indentEmit($eq, ASPrettyPrinter.Break_Arithmetic_Ops_code);}  relationalExpressionNoIn {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;    

//11.8 Relational Operators
relationalExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        shiftExpression 
    	(
	    	( g=GT (assign=ASSIGN)? 
		        {if (assign!=null)
		         {
		         	g.setText(">=");
		         	g.setType(GTE);
		         }
		         indentEmit($g, ASPrettyPrinter.Break_Arithmetic_Ops_code);
		        } 
	          | eq=(IN|LT|LTE|INSTANCEOF|IS|AS) {indentEmit($eq, ASPrettyPrinter.Break_Arithmetic_Ops_code);}
	        )  
	        shiftExpression {popIndent();}
        )*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;
    
relationalExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        shiftExpression 
    	(
	    	( g=GT (assign=ASSIGN)? 
		        {if (assign!=null)
		         {
		         	g.setText(">=");
		         	g.setType(GTE);
		         }
		         indentEmit($g, ASPrettyPrinter.Break_Arithmetic_Ops_code);
		        } 
	          | eq=(LT|LTE|INSTANCEOF|IS|AS) {indentEmit($eq, ASPrettyPrinter.Break_Arithmetic_Ops_code);}
	        )  
	        shiftExpression {popIndent();}
        )*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;

//11.7 Bitwise Shift Operators
shiftExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        additiveExpression ( 
    		(
    			t1=SHL
    			/*(('<' '<' )=> t1='<' t2='<' 
        		{$t1.getLine() == $t2.getLine() &&
          		$t1.getCharPositionInLine() + 1 == $t2.getCharPositionInLine() }?
      			-> SHL) {t1.setText("<<");}*/
      		|	(('>' '>')=> t1='>' t2='>'
        		{ $t1.getLine() == $t2.getLine() && 
          			$t1.getCharPositionInLine() + 1 == $t2.getCharPositionInLine() }?
      			-> SHR) {t1.setText(">>");}
		    | 	(('>' '>' '>')=> t1='>' t2='>' t3='>'
        		{ $t1.getLine() == $t2.getLine() && 
          			$t1.getCharPositionInLine() + 1 == $t2.getCharPositionInLine() &&
          			$t2.getLine() == $t3.getLine() && 
          			$t2.getCharPositionInLine() + 1 == $t3.getCharPositionInLine() }?
      			-> SHU) {t1.setText(">>>");}
    		) 
    		{indentEmit($t1, ASPrettyPrinter.Break_Arithmetic_Ops_code);} additiveExpression {popIndent();}
    	)*
    	{if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;

//11.6 Additive Operators
additiveExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        multiplicativeExpression (op=(PLUS|SUB){indentEmit($op, ASPrettyPrinter.Break_Arithmetic_Ops_code);}  multiplicativeExpression {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;

//11.5 Multiplicative Operators
multiplicativeExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        unaryExpression ( op=(STAR|DIV|MOD){indentEmit($op, ASPrettyPrinter.Break_Arithmetic_Ops_code);} unaryExpression {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();} 
    ;

//11.4 Unary Operators
unaryExpression
    : (unaryOp)=> unaryOp (unaryExpression | postfixExpression)
//    | postfixExpression
//      | unaryOp (unaryExpression | postfixExpression)
//    |  op=(NOT | INV) {emit($op);} unaryExpression
//    |   unaryOp postfixExpression
    
    
    ;

unaryOp
    :   op=(DELETE | VOID | TYPEOF | INC | DEC | PLUS | SUB | INV | NOT) {emit($op);}
    ;


//11.3 Postfix Expressions
postfixExpression
    :   leftHandSideExpression postfixOp?
    ;
    
postfixOp
    :   op=(INC | DEC){emit($op);}
    ;

//These rules came from a grammar by Patrick Hulsmeijer, posted to the ANTLR examples
memberExpression
	: primaryExpression
	| functionExpression
	| newExpression
	;

newExpression
	: N=NEW  {emit($N);} primaryExpression
	;

//11.2
leftHandSideExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    boolean pushedWrapInfo=false;
}
    : {pushedWrapInfo=pushWrapInfo(options, true);}
    memberExpression 
//    (
//      arguments
//      | L=LBRACK {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideArrayReferenceBrackets());} expression R=RBRACK{insertWS(mPrinter.getAdvancedSpacesInsideArrayReferenceBrackets());emit($R);}
//      | D=DOT
//      (
//           {wrapEmit($D, ASPrettyPrinter.Break_Other_Connectors_code);} parExpression {popIndent();}
//         | {wrapEmit($D, ASPrettyPrinter.Break_Function_Calls_code);} eitherIdentifier 
//         	(op=XML_NS_OP {wrapEmit($op, ASPrettyPrinter.Break_Other_Connectors_code);} {popIndent();} eitherIdentifier)? 
//         	{popIndent();}
//      ) 
//      | typePostfixSyntax
//      | E=XML_ELLIPSIS{wrapEmit($E, ASPrettyPrinter.Break_Other_Connectors_code);} eitherIdentifier (op=XML_NS_OP {wrapEmit($op, ASPrettyPrinter.Break_Other_Connectors_code);} {popIndent();} eitherIdentifier)? {popIndent();}
//    )*
    {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;
    
eitherIdentifier
	: I=IDENTIFIER  {emit($I);} 
	 | xmlPropertyIdentifier
//	 | allKeywords
	;
	
typeSpecifier:
	I=IDENTIFIER {emit($I);} | notQuiteReservedWord | I=INTERNAL {emit($I);} | D=DEFAULT {emit($D);}
	;
	
notQuiteReservedWord
	: 
	word=(TO | NATIVE | EACH | GET | SET | NAMESPACE | DYNAMIC | FINAL | OVERRIDE | STATIC ) {emit($word);}
	;

allKeywords
	: (reservedWord | notQuiteReservedWord)
	;
reservedWord
	:
    word=(AS          
    | BREAK           
    | CASE  
    | CATCH           
    | CLASS 
    | CONST
    | CONTINUE
    | DEFAULT
    | DELETE
    | DO
    | ELSE
    | EXTENDS
    | FALSE
    | FINALLY
    | FOR
    | FUNCTION
    | IF
	| IMPLEMENTS
    | IMPORT          
    | IN
    | INSTANCEOF      
    | INTERFACE
    | INTERNAL        
    | IS
//    | NATIVE          
    | NEW
    | NULL            
    | PACKAGE  
    | PRIVATE         
    | PROTECTED
    | PUBLIC          
    | RETURN
    | SUPER           
    | SWITCH
    | THIS            
    | THROW
	| TRUE
    | TRY             
    | TYPEOF
    | USE             
    | VAR
    | VOID            
    | WHILE
    | WITH 
//    | EACH            
// 	| GET
//    | SET             
//    | NAMESPACE
    | INCLUDE         
//    | DYNAMIC
//    | FINAL           
//    | OVERRIDE
//    | STATIC)
       ) 
       {emit($word);}      
	;
	
arguments
@init
{
	WrapOptions options=mPrinter.getMethodCallWrapOptions();
	boolean pushedFormat=false;
	boolean pushedIndent=false;
	boolean pushedWrapInfo=false;
	int firstArgPos=0;
}
	: 
	  {pushedFormat=pushFormatType(options, true);
	   pushedWrapInfo=pushWrapInfo(options, true);
	  }
	  L=LPAREN {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParens());} 
	  ( {pushedIndent=pushLazyParmIndent(pushedIndent, options.getIndentStyle());} {mPrinter.captureNextTextPosition();} assignmentExpression {firstArgPos=mPrinter.getLastCapturePosition();} 
	        (  
		        C=COMMA 
		        {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, firstArgPos);}
		        assignmentExpression 
	        )* 
	  )? 
	  R=RPAREN{insertWS(mPrinter.getAdvancedSpacesInsideParens());emit($R);}
      {
        if (pushedIndent)
   	    	popIndent();
   	    if (pushedFormat)
   	    {
   	    	mPrinter.popFormatMode();
   	    }
   	    if (pushedWrapInfo)
   	    	mPrinter.popWrapContext();
      } 
	;

/*suffix helper rule*/ 
suffix
    :    indexSuffix | propertyReferenceSuffix
    ;
/*code like [i] or [1]*/     
indexSuffix             
    :    L=LBRACK  {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideArrayReferenceBrackets());} expression  R=RBRACK{insertWS(mPrinter.getAdvancedSpacesInsideArrayReferenceBrackets());emit($R);} 
    ;
    
propertyReferenceSuffix
    :    D=DOT  {wrapEmit($D, ASPrettyPrinter.Break_Other_Connectors_code);} I=IDENTIFIER{emit($I);} {popIndent();} 
    |    D=DOT  {wrapEmit($D, ASPrettyPrinter.Break_Other_Connectors_code);} xmlPropertyIdentifier {popIndent();}
    |    D=DOT  {wrapEmit($D, ASPrettyPrinter.Break_Other_Connectors_code);} {popIndent();} /*it's a xml only reference match*/
    ;

//11.1 Primary Expression
primaryExpression  
    :    primaryExpressionHelper
    ;
    
/* derived from ECMA-262 basicly. but add super alternative*/
primaryExpressionHelper
    : (xmlPrimaryExpression)=>xmlPrimaryExpression
    |   T=THIS{emit($T);}
    |   S=SUPER{emit($S);} 
    |   literal  
    |   arrayLiteral // ARRAY_LITERAL
    |   objectLiteral  // OBJECT_LITERAL
    |   identifierLiteral (x=XML_NS_OP {emit($x);} identifierLiteral)? 
    |   parExpression // PAR_EXPRESSION
    ;

//11.1.5 Object Initialiser
objectLiteral
    :   L=LCURLY {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideObjectBraces());pushIndent(true);} propertyNameAndValueList? R=RCURLY {popIndent();insertWS(mPrinter.getAdvancedSpacesInsideObjectBraces());emit($R);} 
    ;

propertyNameAndValueList
@init
{
	WrapOptions options=mPrinter.getArrayInitWrapOptions();
	boolean pushedFormat=false;
	boolean pushedIndent=true; //so that we won't push another indent
	boolean pushedWrapInfo=false;
}
    :
	  {pushedFormat=pushFormatType(options, true);
	   pushedWrapInfo=pushWrapInfo(options, true);
	  }
       propertyNameAndValue (C=COMMA {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, -1);} propertyNameAndValue)*
      {
//        if (pushedIndent)
//   	    	popIndent();
   	    if (pushedFormat)
   	    {
   	    	mPrinter.popFormatMode();
   	    }
   	    if (pushedWrapInfo)
   	    	mPrinter.popWrapContext();
      } 
    ;

propertyNameAndValue
    :   propertyName C=COLON 
    		{
    		emit($C);
    		insertWS(mPrinter.getSpacesAfterLabel());
    		} 
    		assignmentExpression
    ;

propertyName
    :   identifierLiteral 
    |   stringLiteral 
    |   numericLiteral 
    ;

//11.1.4 Array Initialiser
arrayLiteral
    :   L=LBRACK {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideArrayDeclBrackets());} elementList? R=RBRACK{insertWS(mPrinter.getAdvancedSpacesInsideArrayDeclBrackets());emit($R);} 
    ;

elementList
@init
{
	WrapOptions options=mPrinter.getArrayInitWrapOptions();
	boolean pushedFormat=false;
	boolean pushedIndent=false;
	boolean pushedWrapInfo=false;
	int firstItemPos=0;
}
    :
    	{pushedFormat=pushFormatType(options, true);}
    	{
		 pushedIndent=pushLazyParmIndent(pushedIndent, options.getIndentStyle());
    	 pushedWrapInfo=pushWrapInfo(options, true);}
        {mPrinter.captureNextTextPosition();} assignmentExpression {firstItemPos=mPrinter.getLastCapturePosition();} 
    	(
    		C=COMMA 
    		{pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, firstItemPos);}
    		assignmentExpression
    	)* (C=COMMA {emit($C);})? //allow extra comma on end, because it's apparently tolerated
    	
		{
			if (pushedIndent)
				popIndent();
    	    if (pushedFormat)
    	    {
    	    	mPrinter.popFormatMode();
    	    }
    	    if (pushedWrapInfo)
    	    	mPrinter.popWrapContext();
		} 
    ;
